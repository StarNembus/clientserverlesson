# Алгоритм - решето Эратосфена
# Опишите словами алгоритм решения задачи
#
# Ввод: натуральное число n
# Вывод: количество простых чисел строго меньше n

n = int(input('n= '))

my_list = []  # создаем пустой список
for i in range(2, n+1):  # пробегаем все числа от 2 до n
    for j in range(2, i):  # проверяем каждое число начиная с 2
        if i % j == 0:   # проверяем деление, если у числа есть хотя бы один делитель, если есть то
            break  # выходим из цикла
    else:
        my_list.append(i)  # иначе число добавлется в список

print(my_list)

# Дан массив N и число k <= len(N)/2
# Возможно ли разбить массив длины N на k подмассивов так,
# чтобы длины самого длинного и самого короткого отличались не более чем на 1? Какими будут длины этих массивов?

def main(arr, n):
    tmp_arr = []
    lenght_arr = len(arr)
    lenght_sub_arr = lenght_arr // n
    rem_div = lenght_arr % n
    start = 0

    for _ in range(n):
        if rem_div:
            end = start + lenght_sub_arr + 1
            rem_div = rem_div - 1
        else:
            end = start + lenght_sub_arr

        tmp_arr.append(arr[start:end])
        start = end
    return tmp_arr


# Дан массив неповторяющихся чисел, который был отсортирован, а затем циклически сдвинут на неизвестное число позиций.
# Опишите без кода и псевдокода алгоритм поиска максимума в таком массиве
# Оцените сложность предложенного алгоритма
# Изменится ли сложность если массив содержит повторяющиеся числа?

# поиск максимума в массиве отсортированных неповторяющихся чисел, который был циклически сдвинут на неизвестное число позиций

# Изначально минимальным числом в массиве будет считаться первое число(с нулевым индексом), а максимальным последнее,
# необходимо вначале найти средний индекс числа, находящегося между ними.
# Если целевое значение меньше, сбрасываем максимальное, чтобы начать новый поиск в левой половине массива,
# если оно больше, сбрасывается минимальное и новый поиск ведется в правой половине.


































